!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.vanilla=e():t.vanilla=e()}(self,()=>(()=>{"use strict";var t={d:(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{ObjNavigator:()=>m,OptionStore:()=>r});class r{constructor(t={}){this.data=t}static as(t){return t instanceof r?t:new r(t)}set(t,e,r){const n=t.name;if(!n)throw new Error("Type must have a name");return this.data[n]||(this.data[n]={}),this.data[n][e]=r,this}get(t,e){let r=t;for(;r;){const t=r.name,n=this.data[t]?.[e];if(void 0!==n)return n;r=Object.getPrototypeOf(r)}}}class n{constructor(t=void 0,e=void 0,r={}){this._parent=t,this._name=e,this._children=r}get parent(){return this._parent}set parent(t){this._parent=t}get name(){return this._name}let(t,e){return this[t]=e,this}letChild(t,e){return this._children[t]=e,e.parent=this,e._name=t,this}get(...t){return this.ancestors().which(e=>t.every(t=>void 0!==e[t])).then(e=>e[t[0]]).what()}getChild(...t){let e=this;for(const r of t)if(e=e?._children?.[r],!e)break;return e}resolve(t){return"string"==typeof t?this.get(t):t}forget(t){return delete this[t],this}isLeaf(){return void 0===this.children().what()}isRoot(){return void 0===this.parent}children(){return l.as(Object.values(this._children))}root(){return this.parent?this.parent.root():this}ancestors(){return l.along(this,t=>t.parent)}}class s extends n{constructor(t=void 0,e=void 0){super(t,void 0),this._last=e,this._length=t?t._length+1:void 0!==e?1:0}static of(...t){return(new s).along(t)}get prev(){return this._parent}get last(){return this._last}get length(){return this._length}let(t,e){throw new Error("A Path is immutable!")}letChild(t,e){throw new Error("A Path is immutable!")}forget(t){throw new Error("A Path is immutable!")}isEmpty(){return 0==this._length}add(t){return new s(0<this.length?this:void 0,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new l;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){const r=new Array(t);let n=this;for(;0<t;)r[t-1]=e(n.last),n=n.prev,t--;return r}}class o{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new o;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){let e;return void 0===t?o.of():t instanceof o?t:(t[Symbol.iterator]||t[Symbol.asyncIterator]?(e=new o,e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e}):(e=new o,e[Symbol.asyncIterator]=async function*(){yield await t}),e)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return o.equal(this,t)}static along(t,e){const r=new o;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await e(r)},r}static async equal(t,e){if("string"==typeof t||!l.isIterable(t)&&!o.isAsyncIterable(t)||"string"==typeof e||!l.isIterable(e)&&!o.isAsyncIterable(e))return t===e;{const r=o.as(t)[Symbol.asyncIterator](),n=o.as(e)[Symbol.asyncIterator]();for(;;){const t=await r.next(),e=await n.next();if(t.done||e.done)return t.done===e.done;if(!await o.equal(t.value,e.value))return!1}}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new o;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)await t(n,r++)&&(yield n)},r}sthen(t){const e=this,r=new o;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)yield await t(n,r++)},r}else(t=void 0){return void 0===t?o.else(this):o.else([this,o.as(t)])}static else(t){const e=new o;return e[Symbol.asyncIterator]=async function*(){for await(const e of o.as(t)){const t=o.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return o.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},o.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new o;return s[Symbol.asyncIterator]=r?async function*(){let r=0,s=!1;for await(const o of t)s?yield o:await e(o,r)&&(s=!0,n&&(yield o)),r++}:async function*(){let r=0,s=!1;for await(const o of t){if(s)break;await e(o,r)?(s=!0,n&&(yield o)):yield o,r++}},s}match(t=void 0){return void 0===t?o.match(this):o.match(this,o.as(t))}static match(...t){const e=new o,r=t.map(t=>o.as(t));return e[Symbol.asyncIterator]=async function*(){const t=r.map(t=>t[Symbol.asyncIterator]());for(;;){const e=await Promise.all(t.map(t=>t.next()));if(e.some(t=>t.done))break;yield e.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return o.each(...this);const e=this,r=new o;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of o.as(t))yield[r,e]},r}static each(...t){const e=t.map(t=>o.as(t));return h.as(t=>{if(t.length>=e.length)return o.of();const r=e[t.length],n=new o;return n[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},n})}self(){return o.self(this)}static self(t){const e=o.as(t),r=new o;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}async what(t,e){return o.what(this,t,e)}static async what(t,e,r){const n=o.as(t);if(e){let t=void 0!==r;for await(const s of n)t?r=await e(r,s):(r=s,t=!0);return r}for await(const t of n)return t}}class i{static matches(t,e){if("function"==typeof e)try{return e(t)}catch(t){return!1}if(null==t)return!1;if(t===e)return!0;if(t instanceof Error)return this.matches(t.constructor.name,e)||this.matches(t.statusCode,e)||this.matches(t.message,e);if("string"==typeof t){if("string"==typeof e)return t.includes(e);if(e instanceof RegExp)return e.test(t)}return!1}}class a extends Error{constructor(t,e="Operation timed out",r){super(e),this.millis=t,this.name=this.constructor.name,r&&(this.cause=r)}}class c{static of(...t){const e=t.slice(0,-1),r=t.at(-1);return c.as(async(...t)=>await o.equal(e,t)?r:void 0)}static as(t){if(t instanceof c)return t;if("function"!=typeof t){const e=t;t=async()=>e}const e=async(...e)=>await t(...e);return Object.setPrototypeOf(e,c.prototype),e.what=t.bind(e),e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=async t=>void 0!==t,e=void 0){return c.retype(c.if(t,this,e),this)}static if(t,e,r=void 0){return c.as(async(...n)=>{if(await t(...n))return await e(...n);throw r})}sthen(...t){return c.retype(c.sthen(this,...t),this)}static sthen(...t){return c.as(async e=>{let r=e;for(let e of t)r=await e(r);return r})}else(t,e=void 0){return t=c.as(t),c.retype(async(...r)=>{let n;try{n=await this(...r)}catch(n){if(!e||i.matches(n,e))return await t(...r,n);throw n}return void 0===n?await t(...r):n},this)}which(t=async t=>void 0!==t,e=void 0){return c.retype(c.which(this,t,e),this)}static which(t,e=async t=>void 0!==t,r=void 0){return c.as(async(...n)=>{const s=await t(...n);if(await e(s,...n))return s;if(void 0!==r)throw r})}when(t,e,r,n=void 0,s=!0){return c.when(t,this,e,r,n,s)}static when(t,e,r,n,s,o=!0){const i=c.as(async(...i)=>(o||e(...i),new Promise((i,c)=>{let h;const l=async(...n)=>{try{await t(...n,r)&&(u(),e.stopped=!o,o?i(await e(...n,r)):i())}catch(t){u(),c(t)}},u=()=>{h&&clearTimeout(h),"function"==typeof r.off?r.off(n,l):"function"==typeof r.removeEventListener&&r.removeEventListener(n,l)};if("function"==typeof r.on)r.on(n,l);else{if("function"!=typeof r.addEventListener)throw new Error("Unsupported emitter type");r.addEventListener(n,l)}s>0&&(h=setTimeout(()=>{u(),c(new a(`Event "${n}" timed out after ${s}ms`))},s))})));return Object.defineProperty(i,"stopped",{get:()=>e.stopped,set:t=>e.stopped=t}),i}match(...t){return c.retype(c.match(this,...t),this)}static match(...t){const e=t.length<2?async e=>[e,await t[0](e)]:async e=>{const r=[];for(let n of t)r.push(await n(e));return r};return c.as(e)}each(t){return c.retype(async(...e)=>await o.as(await this(...e)).which().sthen(t).which().else().toArray(),this)}static each(...t){return c.as(async e=>{const r=e instanceof s?e:s.of(e);return r.length>t.length?l.of():r.across(await o.as(await c.as(t[r.length-1])(r.last)).which().toArray()).which()})}self(...t){return c.retype(c.self(this,...t),this)}static self(t,...e){let r;if(0===e.length)return r=async e=>e.across(await o.as(await t(e.last)).which().toArray()),c.as(r);if("number"!=typeof e[0]){const[r,n]=e;return c.nominal(t,r,n)}if(1===e.length)return c.within(e[0],t);if(2===e.length){const[r,n]=e;return c.partial(t,r,n)}return c.retry(t,...e)}static partial(t,e,r){return c.as(async(...n)=>t(...n.slice(0,e),r,...n.slice(e)))}static nominal(t,e,r){let n;return n=void 0===e?async(...e)=>{const n=await t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:async n=>{const s=await o.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t).toArray(),i=await("string"==typeof t?n[t]:t)(...s);return void 0!==r?(n[r]=i,n):i},c.as(n)}static within(t,e,r=new a(`Operation timed out after ${t}ms`)){return c.as(async n=>{let s;try{return await Promise.race([e(n),new Promise((e,n)=>{s=setTimeout(()=>n(r),t)})])}finally{clearTimeout(s)}})}static retry(t,e=1/0,r=100,n=1,s=1/0){let o=!1;const i=c.as(async i=>{let a=0,c=null;for(;!o&&a<e;)try{const e=await t(i);if(void 0===e)throw new Error("AsyncWhat.retry: undefined result (will retry)");return e}catch(t){c=t;const e=Math.min(r*n**a,s);await new Promise(t=>setTimeout(t,e)),a++}throw o?new Error("Retry stopped by user"):c});return Object.defineProperty(i,"stopped",{get:()=>o,set:t=>{o=Boolean(t)}}),i}}class h{static of(...t){const e=t.slice(0,-1),r=t.at(-1);return h.as((...t)=>l.equal(e,t)?r:void 0)}static as(t){if(t instanceof h)return t;if("function"!=typeof t){const e=t;t=()=>e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,h.prototype),e.what=t.bind(e),e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=t=>void 0!==t,e=void 0){return h.retype(h.if(t,this,e),this)}static if(t,e,r=void 0){return h.as((...n)=>{if(t(...n))return e(...n);if(void 0!==r)throw r})}sthen(t){return h.retype(h.sthen(this,t),this)}static sthen(...t){return h.as(e=>{let r=e;for(let e of t)r=e(r);return r})}else(t,e){return t=h.as(t),h.retype((...r)=>{let n;try{n=this(...r)}catch(n){if(!e||i.matches(n,e))return t(...r,n);throw n}return void 0===n?t(...r):n},this)}which(t=t=>void 0!==t,e=h.WHICH_ERROR){return h.retype(h.which(this,t,e),this)}static which(t,e=t=>void 0!==t,r=void 0){return h.as((...n)=>{const s=t(...n);if(e(s,...n))return s;if(void 0!==r)throw r})}when(t,e,r,n=void 0,s=!0){return c.when(t,this,e,r,n,s)}match(...t){return h.retype(h.match(this,...t),this)}static match(...t){const e=t.length<2?e=>[e,t[0](e)]:e=>t.map(t=>t(e));return h.as(e)}each(t){return h.retype((...e)=>l.as(this(...e)).which().sthen(t).which().else(),this)}static each(...t){return h.as(e=>{const r=e instanceof s?e:s.of(e);return r.length>t.length?l.of():r.across(l.as(h.as(t[r.length-1])(r.last)).which()).which()})}self(...t){return h.retype(h.self(this,...t),this)}static self(t,...e){let r;if(0===e.length)return r=e=>e.across(l.as(t(e.last)).which().toArray()),h.as(r);if("number"!=typeof e[0]){const[r,n]=e;return h.nominal(t,r,n)}if(2===e.length){const[r,n]=e;return h.partial(t,r,n)}return c.self(t,...e)}static partial(t,e,r){return h.as((...n)=>t(...n.slice(0,e),r,...n.slice(e)))}static nominal(t,e,r){let n;return n=void 0===e?(...e)=>{const n=t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:n=>{const s=l.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t).toArray(),o=("string"==typeof t?n[t]:t)(...s);return void 0!==r?(n[r]=o,n):o},h.as(n)}}class l{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return l.of();if(t instanceof l)return t;if(t[Symbol.iterator]){const e=new l;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new l;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new l;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new l;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=e(r)},r}toArray(){return Array.from(this)}equals(t){return l.equal(this,t)}static equal(t,e){if("string"==typeof t||!l.isIterable(t)||"string"==typeof e||!l.isIterable(e))return t===e;{const r=t[Symbol.iterator](),n=e[Symbol.iterator]();for(;;){const t=r.next(),e=n.next();if(t.done||e.done)return t.done===e.done;if(!l.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return l.if(this,t)}static if(t,e=t=>void 0!==t){return l.which(t,e)}sthen(t){return l.sthen(this,t)}static sthen(t,e){const r=new l;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)yield e(n,r++)},r}else(t=void 0){return void 0===t?l.else(this):l.else(l.of(this,l.as(t)))}static else(t){const e=new l;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return l.which(this,t)}static which(t,e=t=>void 0!==t){const r=new l;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)e(n,r++)&&(yield n)},r}when(t,e=!0,r=e){return l.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},o.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new l;return s[Symbol.iterator]=r?function*(){let r=0,s=!1;for(let o of t)s?yield o:e(o,r)&&(s=!0,n&&(yield o)),r++}:function*(){let r=0,s=!1;for(let o of t){if(s)break;e(o,r)?(s=!0,n&&(yield o)):yield o,r++}},s}match(t=void 0){return void 0===t?l.match(...this):l.match(this,l.as(t))}static match(...t){const e=new l;return e[Symbol.iterator]=function*(){const e=t.map(t=>t[Symbol.iterator]());for(;;){const t=e.map(t=>t.next());if(t.some(t=>t.done))break;yield t.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return l.each(...this);const e=this,r=new l;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of l.as(t))yield[r,e]},r}static each(...t){return t=t.map(t=>t[Symbol.iterator]?t:[t]),h.as(e=>e.length<t.length?e.across(t[e.length]):l.of())}self(){return l.self(this)}static self(t){const e=new l;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return l.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=l.what(t),t=l.when(t,1));for(let n of t)r=e(r,n);return r}for(let e of t)return e}}l.NATURAL=new l,l.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++};class u extends l{constructor(){super()}n(){throw new Error("Abstract method: n()")}has(t){throw new Error("Abstract method: has(item)")}add(t){throw new Error("Abstract method: add(item)")}remove(t){throw new Error("Abstract method: remove(item)")}clear(){throw new Error("Abstract method: clear()")}get(t){throw new Error("Abstract method: get(query)")}[Symbol.iterator](){throw new Error("Abstract method: Symbol.iterator()")}create(t){return!this.has(t)&&this.add(t)}read(t){return this.has(t)?l.as(this.get(t)).what():void 0}readAll(t){return this.get(t)}update(t,e,r=!1){return this.has(t)?this.remove(t)&&this.add(e):!!r&&this.add(e)}delete(t){return this.remove(t)}deleteAll(t){return this.removeAll(t)}query(t){return this.get(t)}isEmpty(){return 0===this.n()}let(t){return this.add(t),this}addAll(t){const e=[];for(const r of t)this.add(r)&&e.push(r);return this}removeAll(t){const e=[];for(const r of t)this.remove(r)&&e.push(r);return e}}Symbol.asyncIterator;class f extends u{constructor(){super()}peek(t=!0){throw new Error("Abstract method: peek() must be implemented by subclass.")}poll(t=!0){throw new Error("Abstract method: poll() must be implemented by subclass.")}reverse(){throw new Error("Abstract method: reverse() must be implemented by subclass.")}select(t,e=!0){t<0&&(t=0);const r=this.n()-t,n=new Array(r<0?0:r).fill(void 0);let s=e?n.length-1:0;const o=e?-1:1;for(;this.n()>t;){const t=this.poll(!e);n[s]=t,s+=o}return n}}class y extends f{constructor(t=!0,e=[]){super(),this._fifo=t,this._items=e}get fifo(){return this._fifo}get items(){return this._items}n(){return this.items.length}has(t){return!1}add(t){return this.items.push(t),!0}remove(t){return!1}peek(t=!0){return this.items[this.index(t)]}poll(t=!0){return 0===this.index(t)?this.items.shift():this.items.pop()}index(t){return this.fifo?t?0:this.items.length-1:t?this.items.length-1:0}clear(){return this.items.length=0,!0}[Symbol.iterator](){return this.items[Symbol.iterator]()}reverse(){const t=new l,e=this;return t[Symbol.iterator]=function*(){let t=e.items.length-1;for(;t>=0;)yield e.items[t],t--},t}}class d extends l{start;space;queue;max;constructor(t=void 0,e=void 0,r=new y,n=256){super(),this.start=t,this.space=e,this.queue=r,this.max=n}from(...t){return this.start=t,this}through(t){return this.space=t,this}via(t,e=void 0){return this.queue=t,void 0!==e&&(this.max=e),this}*[Symbol.iterator](){const t=this.queue,e=this.space,r=l.as(this.start),n=this.max;for(t.clear(),t.addAll(r);t.n()>0;){const r=t.poll();let s;try{s=e(r)}catch(t){throw new Error(`Search expansion failed at item: ${r}\n${t}`)}void 0!==s&&(t.addAll(l.as(s)),void 0!==n&&t.select(n)),yield r}}}class m{constructor(t={},e=void 0,r=void 0){this.root=t,this.parent=e,this.step=r}path(t=!1){return this.parent?this.parent.path(t).along(t?this.step.split("."):[this.step]):new s}static from(t){return new m(t)}with(t){return this.within(t)}within(t){const e=m.normalizePath(t);let r=this.root;for(const n of e){if(!(n in r)||"object"!=typeof r[n]||null===r[n])throw new Error(`Path '${t}' does not exist or is not an object`);r=r[n]}return new m(r,this,e.join("."))}without(){return this.parent||null}get(t){const e=m.normalizePath(t);let r=this.root;for(const t of e){if(!(t in r))return;r=r[t]}return r}set(t,e,r=!0){const n=m.normalizePath(t);let s=this.root;for(let t=0;t<n.length-1;t++){const e=n[t];if(e in s&&null!=s[e]){if("object"!=typeof s[e])throw new Error(`Path segment '${e}' is not an object`)}else{if(!r)throw new Error(`Path segment '${e}' does not exist`);s[e]={}}s=s[e]}return s[n.at(-1)]=e,this}delete(t){const e=m.normalizePath(t),r=this.get(e.slice(0,-1));return r&&delete r[e.at(-1)],this}select(t){for(const[e,r]of Object.entries(this.root))t(e,r)||delete this.root[e];return this}search(){return(new d).from(this).through(t=>Object.entries(t.root).map(([e,r])=>new m(r,t,e)))}static normalizePath(t){return Array.isArray(t)?t:t.split(".").filter(Boolean)}}return e})());